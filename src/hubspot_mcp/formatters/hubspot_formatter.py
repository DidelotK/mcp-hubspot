"""Formatters for HubSpot data display."""

import html
import json
from typing import Any, Dict, List, Optional, Union


class HubSpotFormatter:
    """Formatter for HubSpot data display.

    This class provides static methods to format various HubSpot data types
    (contacts, companies, deals, properties) into human-readable text.
    """

    @staticmethod
    def format_contacts(contacts: List[Dict[str, Any]]) -> str:
        """Format the contacts list for display.

        Args:
            contacts: List of contact dictionaries from HubSpot API

        Returns:
            str: Formatted string representation of contacts
        """
        result = f"üë• **HubSpot Contacts** ({len(contacts)} found)\n\n"

        for contact in contacts:
            props = contact.get("properties", {})
            result += f"**{props.get('firstname', '')} {props.get('lastname', '')}**\n"
            result += f"  üìß Email: {props.get('email', 'N/A')}\n"
            result += f"  üè¢ Company: {props.get('company', 'N/A')}\n"
            result += f"  üìû Phone: {props.get('phone', 'N/A')}\n"
            result += f"  üìÖ Created: {props.get('createdate', 'N/A')}\n"
            result += f"  üìÖ Modified: {props.get('lastmodifieddate', 'N/A')}\n"
            result += f"  üÜî ID: {contact.get('id')}\n\n"

        return result + HubSpotFormatter._raw_block(contacts)

    @staticmethod
    def format_companies(companies: List[Dict[str, Any]]) -> str:
        """Format the companies list for display.

        Args:
            companies: List of company dictionaries from HubSpot API

        Returns:
            str: Formatted string representation of companies
        """
        result = f"üè¢ **HubSpot Companies** ({len(companies)} found)\n\n"

        for company in companies:
            props = company.get("properties", {})
            result += f"**{props.get('name', 'Unnamed company')}**\n"
            result += f"  üåê Domain: {props.get('domain', 'N/A')}\n"
            result += f"  üìç City: {props.get('city', 'N/A')}\n"
            result += f"  üìç State: {props.get('state', 'N/A')}\n"
            result += f"  üåç Country: {props.get('country', 'N/A')}\n"
            result += f"  üè≠ Industry: {props.get('industry', 'N/A')}\n"
            result += f"  üìÖ Created: {props.get('createdate', 'N/A')}\n"
            result += f"  üìÖ Modified: {props.get('lastmodifieddate', 'N/A')}\n"
            result += f"  üÜî ID: {company.get('id')}\n\n"

        return result + HubSpotFormatter._raw_block(companies)

    @staticmethod
    def format_deals(deals: List[Dict[str, Any]]) -> str:
        """Format the deals list for display.

        Args:
            deals: List of deal dictionaries from HubSpot API

        Returns:
            str: Formatted string representation of deals
        """
        result = f"üí∞ **HubSpot Deals** ({len(deals)} found)\n\n"

        for deal in deals:
            props = deal.get("properties", {})
            amount = props.get("amount", "0")

            # Format amount if available
            if amount and amount != "0":
                try:
                    amount_float = float(amount)
                    amount_formatted = f"${amount_float:,.2f}"
                except (ValueError, TypeError):
                    amount_formatted = f"${amount}"
            else:
                amount_formatted = "N/A"

            result += f"**{props.get('dealname', 'Unnamed deal')}**\n"
            result += f"  üí∞ Amount: {amount_formatted}\n"
            result += f"  üìä Stage: {props.get('dealstage', 'N/A')}\n"
            result += f"  üîÑ Pipeline: {props.get('pipeline', 'N/A')}\n"
            result += f"  üìÖ Close date: {props.get('closedate', 'N/A')}\n"
            result += f"  üìÖ Created: {props.get('createdate', 'N/A')}\n"
            result += f"  üë§ Owner: {props.get('hubspot_owner_id', 'N/A')}\n"
            result += f"  üÜî ID: {deal.get('id')}\n\n"

        return result + HubSpotFormatter._raw_block(deals)

    @staticmethod
    def format_single_deal(deal: Optional[Dict[str, Any]]) -> str:
        """Format a single deal for display.

        Args:
            deal: Deal dictionary from HubSpot API or None if not found

        Returns:
            str: Formatted string representation of the deal
        """
        if not deal:
            return "üîç **Deal not found**\n\nNo deal matches the specified name."

        props = deal.get("properties", {})
        amount = props.get("amount", "0")

        # Format amount if available
        if amount and amount != "0":
            try:
                amount_float = float(amount)
                amount_formatted = f"${amount_float:,.2f}"
            except (ValueError, TypeError):
                amount_formatted = f"${amount}"
        else:
            amount_formatted = "N/A"

        result = f"üí∞ **HubSpot Deal**\n\n"
        result += f"**{props.get('dealname', 'Unnamed deal')}**\n"
        result += f"  üí∞ Amount: {amount_formatted}\n"
        result += f"  üìä Stage: {props.get('dealstage', 'N/A')}\n"
        result += f"  üîÑ Pipeline: {props.get('pipeline', 'N/A')}\n"
        result += f"  üìÖ Close date: {props.get('closedate', 'N/A')}\n"
        result += f"  üìÖ Created: {props.get('createdate', 'N/A')}\n"
        result += f"  üìÖ Modified: {props.get('lastmodifieddate', 'N/A')}\n"
        result += f"  üë§ Owner: {props.get('hubspot_owner_id', 'N/A')}\n"
        result += f"  üÜî ID: {deal.get('id')}\n"

        return result

    @staticmethod
    def format_contact_properties(properties: List[Dict[str, Any]]) -> str:
        """Format the contact properties list for display.

        Args:
            properties: List of property dictionaries from HubSpot API

        Returns:
            str: Formatted string representation of contact properties
        """
        if not properties:
            return (
                "‚ùå **No properties found**\n\nUnable to retrieve contact properties."
            )

        result = f"üîß **HubSpot Contact Properties** ({len(properties)} properties)\n\n"

        # Group properties by group
        grouped_properties: Dict[str, List[Dict[str, Any]]] = {}
        for prop in properties:
            group_name = prop.get("groupName", "Other")
            if group_name not in grouped_properties:
                grouped_properties[group_name] = []
            grouped_properties[group_name].append(prop)

        # Display by group
        for group_name, group_props in grouped_properties.items():
            result += f"## üìÅ {group_name}\n\n"

            for prop in group_props:
                name = prop.get("name", "N/A")
                label = prop.get("label", "N/A")
                type_info = prop.get("type", "N/A")
                field_type = prop.get("fieldType", "N/A")
                description = prop.get("description", "")

                # Icon based on field type
                icon = "üìù"
                if field_type == "date":
                    icon = "üìÖ"
                elif field_type == "number":
                    icon = "üî¢"
                elif field_type == "select":
                    icon = "üìã"
                elif field_type == "checkbox":
                    icon = "‚òëÔ∏è"
                elif field_type == "textarea":
                    icon = "üìÑ"
                elif field_type == "file":
                    icon = "üìé"
                elif name in ["email", "hs_email_domain"]:
                    icon = "üìß"
                elif name in ["phone", "mobilephone"]:
                    icon = "üìû"
                elif name in ["company", "associatedcompanyid"]:
                    icon = "üè¢"

                result += f"**{icon} {label}**\n"
                result += f"  üè∑Ô∏è Name: `{name}`\n"
                result += f"  üîß Type: {type_info} ({field_type})\n"

                if description:
                    result += f"  üìù Description: {description}\n"

                # Options for select fields
                if field_type == "select" and "options" in prop:
                    options = prop["options"]
                    if options:
                        option_labels = [
                            opt.get("label", opt.get("value", ""))
                            for opt in options[:5]
                        ]
                        if len(options) > 5:
                            option_labels.append(f"... and {len(options) - 5} more")
                        result += f"  üìã Options: {', '.join(option_labels)}\n"

                result += "\n"

            result += "\n"

        return result

    @staticmethod
    def format_deal_properties(properties: List[Dict[str, Any]]) -> str:
        """Format the deal properties list for display.

        Args:
            properties: List of property dictionaries from HubSpot API

        Returns:
            str: Formatted string representation of deal properties
        """
        if not properties:
            return "‚ùå **No properties found**\n\nUnable to retrieve deal properties."

        result = f"üîß **HubSpot Deal Properties** ({len(properties)} properties)\n\n"

        # Group properties by group
        grouped_properties: Dict[str, List[Dict[str, Any]]] = {}
        for prop in properties:
            group_name = prop.get("groupName", "Other")
            if group_name not in grouped_properties:
                grouped_properties[group_name] = []
            grouped_properties[group_name].append(prop)

        # Display by group
        for group_name, group_props in grouped_properties.items():
            result += f"## üìÅ {group_name}\n\n"

            for prop in group_props:
                name = prop.get("name", "N/A")
                label = prop.get("label", "N/A")
                type_info = prop.get("type", "N/A")
                field_type = prop.get("fieldType", "N/A")
                description = prop.get("description", "")

                # Icon based on field type
                icon = "üìù"
                if field_type == "date":
                    icon = "üìÖ"
                elif field_type == "number":
                    icon = "üî¢"
                elif field_type == "select":
                    icon = "üìã"
                elif field_type == "checkbox":
                    icon = "‚òëÔ∏è"
                elif field_type == "textarea":
                    icon = "üìÑ"
                elif field_type == "file":
                    icon = "üìé"
                elif name in ["amount", "hs_deal_amount"]:
                    icon = "üí∞"
                elif name in ["dealname", "hs_deal_name"]:
                    icon = "üè∑Ô∏è"
                elif name in ["dealstage", "hs_deal_stage"]:
                    icon = "üìä"
                elif name in ["pipeline", "hs_pipeline"]:
                    icon = "üîÑ"
                elif name in ["closedate", "hs_closedate"]:
                    icon = "üìÖ"

                result += f"**{icon} {label}**\n"
                result += f"  üè∑Ô∏è Name: `{name}`\n"
                result += f"  üîß Type: {type_info} ({field_type})\n"

                if description:
                    result += f"  üìù Description: {description}\n"

                # Options for select fields
                if field_type == "select" and "options" in prop:
                    options = prop["options"]
                    if options:
                        option_labels = [
                            opt.get("label", opt.get("value", ""))
                            for opt in options[:5]
                        ]
                        if len(options) > 5:
                            option_labels.append(f"... and {len(options) - 5} more")
                        result += f"  üìã Options: {', '.join(option_labels)}\n"

                result += "\n"

            result += "\n"

        return result

    @staticmethod
    def format_company_properties(properties: List[Dict[str, Any]]) -> str:
        """Format the company properties list for display.

        Args:
            properties: List of property dictionaries from HubSpot API

        Returns:
            str: Formatted string representation of company properties
        """
        if not properties:
            return (
                "‚ùå **No properties found**\n\nUnable to retrieve company properties."
            )

        result = f"üè¢ **HubSpot Company Properties** ({len(properties)} properties)\n\n"

        # Group properties by group
        grouped_properties: Dict[str, List[Dict[str, Any]]] = {}
        for prop in properties:
            group_name = prop.get("groupName", "Other")
            if group_name not in grouped_properties:
                grouped_properties[group_name] = []
            grouped_properties[group_name].append(prop)

        # Display by group
        for group_name, group_props in grouped_properties.items():
            result += f"## üìÅ {group_name}\n\n"

            for prop in group_props:
                name = prop.get("name", "N/A")
                label = prop.get("label", "N/A")
                type_info = prop.get("type", "N/A")
                field_type = prop.get("fieldType", "N/A")
                description = prop.get("description", "")

                # Icon based on field type
                icon = "üìù"
                if field_type == "date":
                    icon = "üìÖ"
                elif field_type == "number":
                    icon = "üî¢"
                elif field_type == "select":
                    icon = "üìã"
                elif field_type == "checkbox":
                    icon = "‚òëÔ∏è"
                elif field_type == "textarea":
                    icon = "üìÑ"
                elif field_type == "file":
                    icon = "üìé"
                elif name in ["domain", "website"]:
                    icon = "üåê"
                elif name in ["industry", "type"]:
                    icon = "üè≠"
                elif name in ["city", "state", "country"]:
                    icon = "üìç"

                result += f"**{icon} {label}**\n"
                result += f"  üè∑Ô∏è Name: `{name}`\n"
                result += f"  üîß Type: {type_info} ({field_type})\n"

                if description:
                    result += f"  üìù Description: {description}\n"

                # Options for select fields
                if field_type == "select" and "options" in prop:
                    options = prop["options"]
                    if options:
                        option_labels = [
                            opt.get("label", opt.get("value", ""))
                            for opt in options[:5]
                        ]
                        if len(options) > 5:
                            option_labels.append(f"... and {len(options) - 5} more")
                        result += f"  üìã Options: {', '.join(option_labels)}\n"

                result += "\n"

            result += "\n"

        return result

    @staticmethod
    def format_deal(deal: Dict[str, Any]) -> str:
        """Format a single deal for display.

        Args:
            deal: Deal dictionary from HubSpot API

        Returns:
            str: Formatted string representation of the deal
        """

        def clean(val: Any, default: str) -> str:
            """Clean a value for display.

            Args:
                val: Value to clean
                default: Default value if cleaning fails

            Returns:
                str: Cleaned value
            """
            if val is None:
                return default
            return str(val)

        props = deal.get("properties", {})
        amount = props.get("amount", "0")

        # Format amount if available
        if amount and amount != "0":
            try:
                amount_float = float(amount)
                amount_formatted = f"${amount_float:,.2f}"
            except (ValueError, TypeError):
                amount_formatted = f"${amount}"
        else:
            amount_formatted = "N/A"

        result = f"üí∞ **HubSpot Deal**\n\n"
        result += f"**{clean(props.get('dealname'), 'Unnamed deal')}**\n"
        result += f"  üí∞ Amount: {amount_formatted}\n"
        result += f"  üìä Stage: {clean(props.get('dealstage'), 'N/A')}\n"
        result += f"  üîÑ Pipeline: {clean(props.get('pipeline'), 'N/A')}\n"
        result += f"  üìÖ Close date: {clean(props.get('closedate'), 'N/A')}\n"
        result += f"  üìÖ Created: {clean(props.get('createdate'), 'N/A')}\n"
        result += f"  üìÖ Modified: {clean(props.get('lastmodifieddate'), 'N/A')}\n"
        result += f"  üë§ Owner: {clean(props.get('hubspot_owner_id'), 'N/A')}\n"
        result += f"  üÜî ID: {clean(deal.get('id'), 'N/A')}\n"

        return result

    @staticmethod
    def format_engagements(engagements: List[Dict[str, Any]]) -> str:
        """Formats a list of HubSpot engagements for display."""
        lines: List[str] = []
        lines.append(f"üìû **HubSpot Engagements** ({len(engagements)} found)\n")
        for eng in engagements:
            props = eng.get("properties", {})
            meta: Dict[str, Any] = props.get(
                "metadata", {}
            )  # May contain type-specific fields

            subject: str = (
                props.get("subject")
                or meta.get("subject")
                or meta.get("title")
                or "No subject"
            )
            body_preview: Optional[str] = meta.get("body") or meta.get("text")

            lines.append(f"**{subject}**")
            lines.append(f"  üîñ Type: {props.get('engagement_type', 'N/A')}")

            # Optional extra info
            if body_preview:
                snippet = body_preview[:60].replace("\n", " ")
                lines.append(f"  üìù Snippet: {snippet}‚Ä¶")

            lines.append(f"  üóìÔ∏è Created: {props.get('createdate')}")
            lines.append(f"  üîÑ Updated: {props.get('lastmodifieddate')}")
            lines.append(f"  üÜî ID: {eng.get('id')}\n")
        return "\n".join(lines) + HubSpotFormatter._raw_block(engagements)

    # ---------------------------------------------------------------------
    # Helpers
    # ---------------------------------------------------------------------

    @staticmethod
    def _raw_block(data: Any) -> str:
        """Return pretty-printed JSON block of *data*.

        The raw payload is useful for debugging or advanced workflows. It is
        appended below the human-readable section, wrapped in a fenced JSON
        code-block so that rich chat UIs will render it collapsible.
        """
        json_str = json.dumps(data, indent=2, ensure_ascii=False)
        return f"\n---\n```json\n{json_str}\n```"
